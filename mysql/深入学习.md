# 数据库三范式

第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。

第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键（也可以是联合主键，即确保每一行的数据是唯一的，不能重复的）；二是非主键字段必须完全依赖于主键（如果是联合主键，必须依赖里面的每一列），而不能只依赖于主键的一部分。

第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖（减少数据更新时的扩散，即修改了A列，还需要同时更新B/C/D列）。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 

![image](https://user-images.githubusercontent.com/13763576/185401018-42fcdced-038b-4ca6-82cf-31bc2b7c1004.png)

上图中“价格”所在列就包含了两种属性：单价和折后价；这就违背了原子性了，因为这个列明明是可以在分的（分为单价列、折后价列）

![image](https://user-images.githubusercontent.com/13763576/185401103-40d78704-30cc-4d10-8723-31709eccecf8.png)

上表中单靠订单号是不符合主键唯一性了，所以要采用联合主键的方式确定每一条记录；假如联合主键为（订单号，产品编码）
上表虽然符合了第一范式，但却不符合第二范式！
因为像产品名称和单价这些并不依赖订单号（联合主键的一部分），需要拆分为不同的表，以确保表中的列都是依赖主键的（如果是联合主键的话，就需要依赖联合主键的所有）
进行以下拆分：

![image](https://user-images.githubusercontent.com/13763576/185401222-0a1c4d25-b09d-4575-a1aa-5177e71fe2d8.png)


![image](https://user-images.githubusercontent.com/13763576/185401273-a6bc8368-215e-4b63-86c6-6604c81a38af.png)

上表中，订单号 -> 用户名称 -> 用户ID，因此如果要修改其中某一项信息的时候就会牵涉较广了（耦合），即用户信息不能单独管理了。

再次拆分处理：

![image](https://user-images.githubusercontent.com/13763576/185401314-efe87fc9-20a4-4069-aca3-9ce8a2549bdb.png)

当然啦，在日常实际开发当中，可能并不会完全遵守三大范式，只能说是具体情况具体分析，假如当前情况在表存在冗余的时候，更方便，那就允许存在一定的冗余。
