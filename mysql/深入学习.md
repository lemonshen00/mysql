https://stibel.icu/md/database/mysql/mysql-basic-datatype-constraint.html

https://notes.diguage.com/mysql/schema-data-type.html#schema-cache-and-summary-table



## 数据库三范式

第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。

第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键（也可以是联合主键，即确保每一行的数据是唯一的，不能重复的）；二是非主键字段必须完全依赖于主键（如果是联合主键，必须依赖里面的每一列），而不能只依赖于主键的一部分。

第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖（减少数据更新时的扩散，即修改了A列，还需要同时更新B/C/D列）。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 

![image](https://user-images.githubusercontent.com/13763576/185401018-42fcdced-038b-4ca6-82cf-31bc2b7c1004.png)

上图中“价格”所在列就包含了两种属性：单价和折后价；这就违背了原子性了，因为这个列明明是可以在分的（分为单价列、折后价列）

![image](https://user-images.githubusercontent.com/13763576/185401103-40d78704-30cc-4d10-8723-31709eccecf8.png)

上表中单靠订单号是不符合主键唯一性了，所以要采用联合主键的方式确定每一条记录；假如联合主键为（订单号，产品编码）
上表虽然符合了第一范式，但却不符合第二范式！
因为像产品名称和单价这些并不依赖订单号（联合主键的一部分），需要拆分为不同的表，以确保表中的列都是依赖主键的（如果是联合主键的话，就需要依赖联合主键的所有）
进行以下拆分：

![image](https://user-images.githubusercontent.com/13763576/185401222-0a1c4d25-b09d-4575-a1aa-5177e71fe2d8.png)


![image](https://user-images.githubusercontent.com/13763576/185401273-a6bc8368-215e-4b63-86c6-6604c81a38af.png)

上表中，订单号 -> 用户名称 -> 用户ID，因此如果要修改其中某一项信息的时候就会牵涉较广了（耦合），即用户信息不能单独管理了。

再次拆分处理：

![image](https://user-images.githubusercontent.com/13763576/185401314-efe87fc9-20a4-4069-aca3-9ce8a2549bdb.png)

当然啦，在日常实际开发当中，可能并不会完全遵守三大范式，只能说是具体情况具体分析，假如当前情况在表存在冗余的时候，更方便，那就允许存在一定的冗余。

## 数据库隔离级别
https://zhuanlan.zhihu.com/p/117476959
mysql事务的几种隔离级别：
读未提交：
MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，所以它连脏读的问题都没办法解决。例子：启动两个事务，分别为事务A和事务B，在事务A中使用 update 语句，修改 age 的值为10，初始是1 ，在执行完 update 语句之后，在事务B中查询 user 表，会看到 age 的值已经是 10 了，这时候事务A还没有提交，而此时事务B有可能拿着已经修改过的 age=10 去进行其他操作了。在事务B进行操作的过程中，很有可能事务A由于某些原因，进行了事务回滚操作，那其实事务B得到的就是脏数据了，拿着脏数据去进行其他的计算，那结果肯定也是有问题的。
![企业微信截图_ac8d6641-e960-4ac5-9636-799cecff10e6](https://user-images.githubusercontent.com/13763576/186169620-237b2bc7-8975-4a43-bcc7-293ab0abcf29.png)


读已提交：

可重复读（默认的级别）

穿行化
