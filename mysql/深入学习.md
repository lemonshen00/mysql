https://stibel.icu/md/database/mysql/mysql-basic-datatype-constraint.html

https://notes.diguage.com/mysql/schema-data-type.html#schema-cache-and-summary-table



## 数据库三范式

第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。

第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键（也可以是联合主键，即确保每一行的数据是唯一的，不能重复的）；二是非主键字段必须完全依赖于主键（如果是联合主键，必须依赖里面的每一列），而不能只依赖于主键的一部分。

第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖（减少数据更新时的扩散，即修改了A列，还需要同时更新B/C/D列）。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 

![image](https://user-images.githubusercontent.com/13763576/185401018-42fcdced-038b-4ca6-82cf-31bc2b7c1004.png)

上图中“价格”所在列就包含了两种属性：单价和折后价；这就违背了原子性了，因为这个列明明是可以在分的（分为单价列、折后价列）

![image](https://user-images.githubusercontent.com/13763576/185401103-40d78704-30cc-4d10-8723-31709eccecf8.png)

上表中单靠订单号是不符合主键唯一性了，所以要采用联合主键的方式确定每一条记录；假如联合主键为（订单号，产品编码）
上表虽然符合了第一范式，但却不符合第二范式！
因为像产品名称和单价这些并不依赖订单号（联合主键的一部分），需要拆分为不同的表，以确保表中的列都是依赖主键的（如果是联合主键的话，就需要依赖联合主键的所有）
进行以下拆分：

![image](https://user-images.githubusercontent.com/13763576/185401222-0a1c4d25-b09d-4575-a1aa-5177e71fe2d8.png)


![image](https://user-images.githubusercontent.com/13763576/185401273-a6bc8368-215e-4b63-86c6-6604c81a38af.png)

上表中，订单号 -> 用户名称 -> 用户ID，因此如果要修改其中某一项信息的时候就会牵涉较广了（耦合），即用户信息不能单独管理了。

再次拆分处理：

![image](https://user-images.githubusercontent.com/13763576/185401314-efe87fc9-20a4-4069-aca3-9ce8a2549bdb.png)

当然啦，在日常实际开发当中，可能并不会完全遵守三大范式，只能说是具体情况具体分析，假如当前情况在表存在冗余的时候，更方便，那就允许存在一定的冗余。

## 数据库隔离级别
https://zhuanlan.zhihu.com/p/117476959
mysql事务的几种隔离级别：
读未提交：
MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，所以它连脏读的问题都没办法解决。例子：启动两个事务，分别为事务A和事务B，在事务A中使用 update 语句，修改 age 的值为10，初始是1 ，在执行完 update 语句之后，在事务B中查询 user 表，会看到 age 的值已经是 10 了，这时候事务A还没有提交，而此时事务B有可能拿着已经修改过的 age=10 去进行其他操作了。在事务B进行操作的过程中，很有可能事务A由于某些原因，进行了事务回滚操作，那其实事务B得到的就是脏数据了，拿着脏数据去进行其他的计算，那结果肯定也是有问题的。
![企业微信截图_ac8d6641-e960-4ac5-9636-799cecff10e6](https://user-images.githubusercontent.com/13763576/186169620-237b2bc7-8975-4a43-bcc7-293ab0abcf29.png)


读已提交：

可重复读（默认的级别）

穿行化

## 数据类型

### 整型

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

### 浮点型

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 FLOAT/DOUBLE/DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。DECIMAL(m, 0) == DECIMAL(m) 

DECIMAL或NUMERIC的最大位数是65。

### 日期和时间

MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。

DATETIME 格式：YYYY-MM-DD HH:MM:SS

TIMESTAMP 格式：YYYYMMDD HHMMSS

DATETIME 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 `8` 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 

TIMESTAMP 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。 MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 

应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 

### 字符串

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 

VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。 

### 如何选择数据类型

数据类型的选择：更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少； 

简单原则: 整形比字符串操作代价更低；实用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等； 

尽量避免NULL: 如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列； 
