https://stibel.icu/md/database/mysql/mysql-basic-datatype-constraint.html

https://notes.diguage.com/mysql/schema-data-type.html#schema-cache-and-summary-table



## 第一章 数据库三范式

第一范式（1NF）: 强调的是列的原子性，即列不能够再分成其他几列。

第二范式（2NF）: 满足 1NF，另外包含两部分内容，一是表必须有一个主键（也可以是联合主键，即确保每一行的数据是唯一的，不能重复的）；二是非主键字段必须完全依赖于主键（如果是联合主键，必须依赖里面的每一列），而不能只依赖于主键的一部分。

第三范式（3NF）: 满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖（减少数据更新时的扩散，即修改了A列，还需要同时更新B/C/D列）。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 

![image](https://user-images.githubusercontent.com/13763576/185401018-42fcdced-038b-4ca6-82cf-31bc2b7c1004.png)

上图中“价格”所在列就包含了两种属性：单价和折后价；这就违背了原子性了，因为这个列明明是可以在分的（分为单价列、折后价列）

![image](https://user-images.githubusercontent.com/13763576/185401103-40d78704-30cc-4d10-8723-31709eccecf8.png)

上表中单靠订单号是不符合主键唯一性了，所以要采用联合主键的方式确定每一条记录；假如联合主键为（订单号，产品编码）
上表虽然符合了第一范式，但却不符合第二范式！
因为像产品名称和单价这些并不依赖订单号（联合主键的一部分），需要拆分为不同的表，以确保表中的列都是依赖主键的（如果是联合主键的话，就需要依赖联合主键的所有）
进行以下拆分：

![image](https://user-images.githubusercontent.com/13763576/185401222-0a1c4d25-b09d-4575-a1aa-5177e71fe2d8.png)


![image](https://user-images.githubusercontent.com/13763576/185401273-a6bc8368-215e-4b63-86c6-6604c81a38af.png)

上表中，订单号 -> 用户名称 -> 用户ID，因此如果要修改其中某一项信息的时候就会牵涉较广了（耦合），即用户信息不能单独管理了。

再次拆分处理：

![image](https://user-images.githubusercontent.com/13763576/185401314-efe87fc9-20a4-4069-aca3-9ce8a2549bdb.png)

当然啦，在日常实际开发当中，可能并不会完全遵守三大范式，只能说是具体情况具体分析，假如当前情况在表存在冗余的时候，更方便，那就允许存在一定的冗余。

## 第二章 数据库隔离级别
https://zhuanlan.zhihu.com/p/117476959
mysql事务的几种隔离级别：
读未提交：
MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，所以它连脏读的问题都没办法解决。例子：启动两个事务，分别为事务A和事务B，在事务A中使用 update 语句，修改 age 的值为10，初始是1 ，在执行完 update 语句之后，在事务B中查询 user 表，会看到 age 的值已经是 10 了，这时候事务A还没有提交，而此时事务B有可能拿着已经修改过的 age=10 去进行其他操作了。在事务B进行操作的过程中，很有可能事务A由于某些原因，进行了事务回滚操作，那其实事务B得到的就是脏数据了，拿着脏数据去进行其他的计算，那结果肯定也是有问题的。
![企业微信截图_ac8d6641-e960-4ac5-9636-799cecff10e6](https://user-images.githubusercontent.com/13763576/186169620-237b2bc7-8975-4a43-bcc7-293ab0abcf29.png)


读已提交：

可重复读（默认的级别）

穿行化

##  第三章 数据类型

### 整型

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

### 浮点型

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 FLOAT/DOUBLE/DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。DECIMAL(m, 0) == DECIMAL(m) 

DECIMAL或NUMERIC的最大位数是65。

### 日期和时间

MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。

DATETIME 格式：YYYY-MM-DD HH:MM:SS

TIMESTAMP 格式：YYYYMMDD HHMMSS

DATETIME 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 `8` 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 

TIMESTAMP 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。 MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 

应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 

### 字符串

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 

VARCHAR 会保留字符串末尾的`空格`，而 CHAR 会删除。 

### 如何选择数据类型

数据类型的选择：更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少； 

简单原则: 整形比字符串操作代价更低；实用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等； 

尽量避免NULL: 如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列； 


##  第四章 视图
> 视图是由数据库中的一个表或多个表导出的虚拟表，其作用是方便用户对数据的操作。

### 视图的概念

视图是一个虚拟表，其内容由查询定义(select)。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，数据库中只存放了视图的定义，而并没有存放视图中的数据，这些数据存放在原来的表中。使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。因此，视图中的数据是依赖于原来的表中的数据的。一旦表中的数据发生改变，显示在视图中的数据也会发生改变。同样对视图的更新，会影响到原来表的数据。 

视图的本质是存储在数据库中的查询的`SQL语句`，它主要出于两种原因：

安全原因，视图可以隐藏一些数据，例如，员工信息表，可以用视图只显示姓名、工龄、地址，而不显示社会保险号和工资数等；

另一个原因是可使复杂的查询易于理解和使用。这个视图就像一个“窗口”，从中只能看到你想看的数据列。这意味着你可以在这个视图上使用SELECT *，而你看到的将是你在视图定义里给出的那些数据列。

### 视图的作用

使操作简单化：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询（select 语句）可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 

增加数据的安全性：通过视图，用户只能查询和修改指定的数据。指定数据之外的信息，用户根本接触不到。这样可以防止敏感信息被未授权的用户查看，增强机密信息的安全性。 

提高表的逻辑独立性：视图可以屏蔽原有表结构变化带来的影响。例如原有表增加列和删除未被引用的列，对视图不会造成影响。同样，如果修改表中的某些列，可以使用修改视图来解决这些列带来的影响。 

### 基本操作

创建视图是指在已经存在的数据库表上建立视图。视图可以建立在一张表中，也可以建立在多张表中。 

创建视图需要具有CREATE VIEW的权限。同时应该具有查询涉及的列的SELECT权限。可以使用SELECT语句来查询这些权限信息。查询语法如下：

```mysql
SELECT Select_priv,Create_view_priv FROM mysql.user WHERE user='root';
```


```mysql
CREATE  VIEW view_student AS SELECT id,name,class FROM student; // 创建视图，但是不指定视图中的列，此时视图中的列就是 id,name,class
CREATE VIEW view_student(stu_id,stu_name,stu_class) AS SELECT id,name,class FROM student; // 创建视图，同时指定视图中的列，此时视图中的列是 stu_id,stu_name,stu_class

ALTER VIEW view_student AS SELECT id,name,class FROM student where id  in (select id from student ); // 更新视图中的列名，从`stu_id,stu_name,stu_class` ----> `id,name,class`

DROP VIEW IF EXISTS view_student; // 删除视图，但是不删除原表数据

UPDATE V_VIEW2 SET POS='高级工程师' WHERE NAME='李楠'; // 更新原表数据

```

## 第五章 基本用法

### 约束

```mysql
主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.
非空 not null: 此字段不允许填写空值.
惟一 unique: 此字段的值不允许重复.
默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.
外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在, 如果存在则填写成功, 如果不存在则填写失败并抛出异常.


create table table_name (
列名字 数据类型 约束
)

```



